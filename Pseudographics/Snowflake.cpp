#include <iostream>
using namespace std;

/* Для рисования снежинки нам в первую очередь понадобится поле и его размер. Для упрощения пусть снежинка будет квадратная, т.к. квадратное поле это мат.матрица, с по-
мощью формул которых легче рисовать. Матрицы это таблицы, а след, и табличный вывод на экран. Квадратные матрицы проще, т.к. у них есть точный центр посередине, а след,
с симметричными рисунками легче работать в квадратной матрице.

Работа с псевдографикой ведется во вложенных циклах (for), и надо привыкать работать со счетчиком когда i=0 и i<N, т.к. в дальнейшем именно такой подход и для счетчика
i, и счетчика j пригодится при работе с данными, например, в массивах, т.к. нумерация при хранении данных везде будет с 0, и также проще посчитать, начиная с 0 и стро-
го меньше N. Будет N строчек, и также N столбцов, и получаем нашу матрицу N * N.

Номер, начинающийся с нуля, относительно матрицы N * N, а также номер строчек и столбцов, мы будем называть индекс.
1. Заготовим поле для нашей снежинки, напишем 2 цикла for с переводом строки и пустым телом вложенного цикла.
2. Нужно поставить звездочку, сказать, что если счетчик i = 2 и при этом счетчик j = 10, то в эту ячейку нарисовать звездочку, и так в каждую ячейку. А если это линия,
то у линии есть какое-то уравнение, написать которое можно оттолкнувшись от уравнения главной или побочной диагонали матрицы. (урок 5 стр.12).

                                                                Теория матриц:
У матриц есть главная диагональ (с правого верхнего угла и вниз) и побочная диагональ (с левого верхнего угла и вниз). По строкам у нас индекс i, по столбцу индекс j.
Главная диагональ соответствует равенству i == j.
Побочная диагональ высчитывается по формуле i + j == N - 1 (в математике i + j == N, но в программировании отчет начинается с 0, поэтому N - 1)
Если оба условия истинны, туда поставим звездочку!
Вертикальная линия в центре матрицы это центр матрицы. Если вся матрица размером N, то центр матрицы N/2 (можно N-1 не писать, т.к. у нас отбрасывается дробная часть).
А где находится этот центр? Что общего у звездочек, находящихся на синей линии? j == N/2. (j отвечает за вертикальное смещение, i за горизонтальное)
А горизонтальная центральная линия высчитывается линия i == N/2. Если линия горизонтальная, то счетчик i задает ей условие. А если линия вертикальная, то счетчик j за-
дает ей условие. Если линия изогнутая, то оба счетчика задают условия.

                                                              Теория заполнения:
Поехали, пишем условия для создания звездочки.
(!) рисунок это не только нужный символ в нужном месте, но еще и фон, который заполняет остальное пространство нашей матрицы. Пишется это в конструкции if else, где в
зоне if будет нужный символ, а в зоне else остальной фон.

(!) каждый блок вывода д/б одинаковым по размеру.
У нас каждый символ занимает определенное количество пикселей на экране, а в консоли символ выводится в виде точичек. И мы видим, что у нас ширина символа в 2 раза
меньше чем его высота (1:2), след, чтобы у нас был квадратный символ, нам нужно вписать 2 символа. Когда мы рисуем псевдографикой, мы сами выбираем размер минимального
значения, которое мы примем за единицу изображения, т.е. размер нашей ячеечки мы выбираем сами. Чтобы сделать нашу ячейку действительно квадратной, решим, что она будет
состоять из двух символов, т.е. две звездочки, два пробела, чтобы все получилось симметрично. Размер каждого выводимого на экран фрагмента изображения д/б одинаковым,
т.к. мы рисуем одинаковыми ячейками.

Как нам объединить все уравнения в одно целое и получить снежинку?
Попробуем через &&. Не выходит! Выходит лишь одинокая звездочка!
Лог.объединение "и" означает, что у нас будет истина лишь тогда, когда выполнятся оба условия, а это будет лишь в точке их пересечения.
Т.о. мы получили не объединение уравнений, а условие центра матрицы (хороший пример для наглядности работы лог.операторов).
А вот || "или" тут нам хорошо подойдет. Одно или другое, а можно и оба сразу! (&& это пересечение, || это совокупность одной плюс другой). */

int main()
{
    cout << "---------------------------------------------------------Snowflake drawing program!--------------------------------------------------------------" << endl;
    int N = 0;                                                                                    // размер снежинки (количество строк и столбцов)
    cout << "Enter the size of a snowflake: "; cin >> N;

    for (int i = 0; i < N; i++)                                                                   // цикл по индексу строки
    {
        for (int j = 0; j < N; j++)                                                               // цикл по индексу столбца
        {
            //if ((i == j)&&(i+j==N-1))cout << "* ";                                              // условие пересечения диагоналей
            if ((i == j) || (i + j == N - 1) || (i == N / 2) || (j == N / 2))cout << "* ";        // общая часть любой снежинки
            else cout << "  ";
        }
        cout << endl;
    }

    /* Принцип действия:
    Принцип действия тот же как и в цикле с таблицей умножения в предыдущей лекции. Мы также внешним циклом перемещаемся по строкам вниз при помощи cout << endl; как
    только внутренниц цикл for полностью отработает. Внутренний цикл for отрабатывает все свои итерации при каждом новом ходе внешнего цикла for, заполняя нужным симво-
    лом в зоне конструкции if, а если нужного условия нет, то в зоне else пробелом, тем самым двигаясь лишь вправо при каждом новом шаге внутреннего цикла. Данная схема
    выводит нам на экран таблицу из нужных нам символов.

    (!) Построение самой снежинки в конструкции if внутреннего цикла:
    Вместо формулы перемножения, как в таблице умножения, мы используем матричные формулы главной и побочной диагонали, а также центральных вертикальной и горизонталь-
    ной линий. При каждом шаге внутреннего цикла происходит подсчет каждого из этих уравнений на истину либо ложь (если их левая и правая части равны, при соответствую-
    щих шагах циклов i и j). Если равенство выполнилось, то для соответствующего шага по i и j мы ставим в конкретную ячейку звездочку. Если высчиталось неравенство, то
    это уравнение игнорируется. Фиксируется значение i (шаг внешнего цикла), и во внутреннем оно перебирается с каждым новым j. Где высчитается, там ставится звездочка,
    Заполнение идет справа налево, как описано в принципе действия.

    (!) снежинка получается как надо только при нечетном заданном числе. При четном же у нас есть сдвиг. Это связано с длиной и шириной. Смещение центра. Когда у нас
    нечетное число, у нас есть точный центр - одна ячейка. А при четном числе у нас нет такого центра в одну ячейку, нет этой середины. Тут есть 4 подхода решения воп-
    роса, т.к. когда говорят про графику (любую графику, даже 3D), у нас м/б разные размеры экрана, разное количество пикселей в разрешении. Как тут быть:

    1. Изменить размер. Если пользователь вводит 10, мы отнимает единицу (но не прибавляем, чтобы не выйти за пределы экрана). Минус 1 пиксель никто не увидит. Мы прос-
    то пишем что 10 это 9, 12 будет 11 и т.д. Реальные размеры экрана/поля мы корректируем под те, которые нужны нам. Этот способ самый простой, но не самый предпочти-
    тельный, т.к. могут появиться полосочки у края экрана.

    2. Самый частый способ. При нечетном числе у нас центр был 1 пиксель, а при четном стало объединение из 4 или 6 пикселей и закрашиваем их одним цветом (такой новый
    большой центр из нескольких ячеек). Т.е. мы минимальный размер ячейки масштабируем в длину и в ширину и пишем что у нас теперь каждая ячечка ни один пиксель, а нап-
    ример 6. Когда речь идет о пикселях, то это незаметно. Но у нас тут символы большие, поэтому этот вариант будет сильно бросаться в глаза.

    3. Полностью перерисовать рисунок. Это будет снежинка, но полностью по другому принципу построенная, не нашими уравнениями, а как-то совсем иначе. И так очень часто
    работают в 3D графике, например когда разрешение не то которое нужно, меняют текстуры, т.е. сами картинки, которыми заполнены 3D объекты. Это полностью дубликат ри-
    сунка, но с другими параметрами, иначе сделанный. Выполняется с конструкцией if else. Если у нас четная ширина, то мы вообще рисуем иначе. Это будет снежинка, но
    совсем другая.

    4. Внести небольшие изменения в тот рисунок, который уже есть, но рисунок будет немного другой, но тоже приемлемый.
    У нас в снежинке мы можем дорисовать еще одну вертикальную и горизонтальную линию. В таком случае снежинка получится другая, но тоже симметричная. Дорисуем горизон-
    тальную линию сверху и вертикальную линию слева. Т.о. весь код для нечетной снежинки останется, а для четной мы дорисуем две линии. Смещая счетчики i и j, мы можем
    двигаться по нашей таблице относительно какого-то места.
    В левом верхнем углу нашей таблицы мы имеем координаты 0;0, в внизу справа N-1; N-1.
    При движении к нулю мы уменьшаем счетчик. При движении от нуля, увеличиваем. Сдвиг на строку равен сдвигу на 1, след, уравнения линий будут следующими:

                Уравнение горизонтальной линии:                       Уравнение вертикальной линии:
                          i==N/2-1                                              j==N/2-1

    Т.о. мы можем двигаться по нашей таблице в любом направлении от любого места, от центра, от края, от верхней, от нижней границы, от левой, от правой. Плюсуя счетчик
    i, движемся вниз, минусуя, вверх. Плюсуя счетчик j, движеся вправо, минусуя, влево.

    Перепишем ниже код, добавив в него условие для четного значения N. */

    N = 0;
    cout << "Enter the size of a snowflake: "; cin >> N;

    for (int i = 0; i < N; i++)
    {
        for (int j = 0; j < N; j++)
        {
            if ((i == j) || (i + j == N - 1) || (i == N / 2) || (j == N / 2))cout << "* ";
            else
            {
                if (N % 2 == 0)                                                          // если размер четный
                {
                    if ((i == N / 2 - 1) || (j == N / 2 - 1))cout << "* ";               // дорисовать две линии для звездочки
                    else cout << "  ";
                }
                else cout << "  ";                                                       // иначе, если размер нечетный, заполним пробелом
            }
        }
        cout << endl;
    }
}