#include <iostream>
#include <stdlib.h>
#include <time.h>
using namespace std;
/* ДМ это тоже матрица (хранилище в виде матрицы), к которому тоже применяются формулы матриц. Изучив массивы, я могу не только что-то выводить на экран как "дом", но и
хранить табличные данные и работать с ними.
Задача: создать квадратную матрицу размером N, заполнить ее случайными числами и найти значение min и max, но не среди всех элементов матрицы, а среди тех, которые вы-
берет пользователь из предложенных вариантов в л.7. Каждый рисунок в л.7 пронумерован алфавитными буквами.

Если пользователь выберает вариант а), то элементы должны находиться в закрашенной части рисунка а). Нужно взять эти закрашенные элементы и среди них найти min и max, а
потом вывести только их на экран. Min и max ищутся среди закрашенных элементов, а не среди всего массива. Пользователь выберет какую часть массива надо обработать (сам
массив всегда один). В прошлой лекции за min/max принимались нулевые элементы по строке или столбцу. А теперь строки и столбцы разные, а где и вообще значений не будет.
Что же взять за точку опоры? Если у нас есть какой-то гарантированный элемент, мы берем его за (0;0) и этот элемент становится max. Потом с ним будем сравнивать все ос-
тальные элементы. Если этой возможности нет, можно взять центральный элемент. Он присутствует во всех вариантах. Но если опорный элемент для всех вариантов отсутствует,
можно отталкиваться от значений (если они известны). Наши значения генерируются ГСЧ от -99 до +99, след, зададим значения min и max так, чтобы первый же элемент, участ-
вующий в сравнении, их перебил и сам стал min/max. Чтобы элемент стал max, он должен быть меньше чем -99, хотя бы -100. Можно написать и -1000, разницы не будет. Глав-
ная логика: мы должны для max задать значение заведомо меньшее чем у любого элемента. У min наоборот, необходимо задать значение заведомо большее чем у любого элемента
(но только если мы не можем от какого-то конкретного элемента отталкиваться). */

int main()
{
    system("chcp 1251");
    system("cls");
    srand(time(NULL));
    const int N = 11;
    int Matrix[N][N]{};
    int max = -100;                                                         // задание заведомо меньшего значения чем у любого элемента
    int min = 100;                                                          // задание заведомо большего значения чем у любого элемента
    char dark_side = '0';                                                   // хранение выбора набора элементов

    // заполню матрицу двузначными случайными числами от -99 до 99 включительно
    for (int i = 0; i < N; i++)
    {
        for (int j = 0; j < N; j++)
        {
            do
            {
                Matrix[i][j] = rand() % (100 - (-99)) - 99;                 //  что и Matrix[i][j] = -99 + rand() % 100(100 - (-99));
            } while (Matrix[i][j] > -10 && Matrix[i][j] < 10);              // оставлю только двузначные числа
        }
    }
    /* Матрицу на экран пока не вывожу, т.к. буду это делать в цикле каждый раз для пользователя. Заполню ее 1 раз, а потом по ходу программы буду работать именно с од-
    ной и той же матрицей (с одним и тем же набором элементов, но только из него выбирать разные кусочки). А теперь напишу цикл работы с матрицей.

    1. Выведу матрицу на экран. В матрицу выведу только значения без индексов (для простоты, удобства, наглядности), а также добавлю перед отрицательными числами пробел
    2. Выведу меню на экран [ а), б), в), ... ]
    3. Далее нужно часть элементов скрыть, а из оставшихся искать min и max

    Чтобы работать с узорами матрицы нужен switch. Чтобы в каждом кейсе не писать свои собственные циклы, создам внутри вложенного цикла один switch.
    Вспомню условия главной и побочной диагонали: область под гл.диагональю (i>j), область над гл.диагональю (i<j). Если неравенство строгое, то сами элементы гл.диаго-
    нали в них не попадают. Если i<=j, то эти элементы находятся над и на гл.диагонали. В выбранной области мне нужно сравнить текущий элемент с max и min. Я прохожу по
    всему массиву, но обрабатываю лишь те элементы, которые находятся в выбранной области. Потом сравню и проверю если этот элемент стал max или min. Если текущий эле-
    мент больше чем max, то он становится max, или если меньше чем min, то он становится min. Мы проверяем каждый элемент на max или min значение, а потом выводим его
    на экран.

    Оставшуюся область заполню пробелами. Значение занимает 2 символа, далее место под минус, а после числа отступ перед другим числом. Получается 4 символа. Размер я-
    чейки будет 4 пробела. Получу половину элементов на экране нарисованную, и это те самые элементы что и в моей основной матрице, просто я взял и обработал только
    часть.

    Далее создам выход из программы нажатием '0' в case '0'. Чтобы отличить выход по ошибке от выхода по '0' нужно изменить dark_side на какую-то букву, например 'N'.
    Это будет некорректный ввод, который выведет из switch по break. Зачем мне это нужно? Потому что у меня вложенные циклы и надо выйти еще и из двух вложенных циклов,
    иначе я так и буду в циклах крутиться несмотря на некорректный ввод. А далее проверю, if (dark_side == '0' || dark_side == 'N')break; Для выхода или из-за ошибки
    введу еще раз break. Этот break выведет из внутреннего цикла, а далее внешний цикл. Тут мне еще раз нужно проверить тоже условие и выйти из внешнего цикла. Если все
    неправильно, то нужно выйти из обоих циклов. После того как все элементы перебраны, при правильном варианте выведу max и min элемент на экран. При непрвильном, вый-
    ду из программы (if (dark_side == '0')break;). А в else напишу случай, когда у меня корректный ввод (if (dark_side != 'N')) и обработаю его. А если неправильный, то
    просто повторю цикл. При правильном вводе выведу min и max элемент на экран. А потом верну переменные max и min в исходное состояние для повторной работы с матрицей.
    Далее нужно прописать условия для остальных узоров.
    (!) max в любом случае будет положительным числом, т.к. маловероятно что во всем блоке не будет положительного числа. */
    do
    {
        system("cls");
        cout << "---------------------------------------------Программа для работы с квадратной матрицей!-----------------------------------------------------" << endl;
        for (int i = 0; i < N; i++)
        {
            for (int j = 0; j < N; j++)
            {
                if (Matrix[i][j] > 0)cout << " ";
                cout << Matrix[i][j] << " ";
            }
            cout << endl;
        }
        cout << R"(
Выберите вариант матрицы:
     * * *        *            * * *                     * * *
а) -   * *   б) - * *     в) -   *     г) -   *     д) -   *
         *        * * *                     * * *        * * *

     *   *        *                *        * * *            *
е) - * * *   ж) - * *     з) -   * *   и) - * *     к) -   * *
     *   *        *                *        *            * * *

0 - Выход
)";
        cin >> dark_side;                                                   // ввод варианта матрицы
        for (int i = 0; i < N; i++)                                         // работа с матрицей в зависимости от вариантов
        {
            for (int j = 0; j < N; j++)
            {
                switch (dark_side)
                {
                case 'А':
                case 'а':
                    if (i <= j)                                 // условие варианта а)
                    {
                        if (Matrix[i][j] > max)max = Matrix[i][j];          // сравнение текущего элемента с максимальным
                        if (Matrix[i][j] < min)min = Matrix[i][j];          // сравнение текущего элемента с минимальным
                        if (Matrix[i][j] > 0)cout << " ";                   // пробел перед положительным знаком
                        cout << Matrix[i][j] << " ";                        // вывод значения элемента с пробелом на экран
                    }
                    else cout << "    ";
                    break;
                case 'Б':
                case 'б':
                    if (i >= j)                                 // условие варианта б)
                    {
                        if (Matrix[i][j] > max)max = Matrix[i][j];
                        if (Matrix[i][j] < min)min = Matrix[i][j];
                        if (Matrix[i][j] > 0)cout << " ";
                        cout << Matrix[i][j] << " ";
                    }
                    else cout << "    ";
                    break;
                case 'В':
                case 'в':
                    if (i <= j && i + j <= N - 1)               // условие варианта в)
                    {
                        if (Matrix[i][j] > max)max = Matrix[i][j];
                        if (Matrix[i][j] < min)min = Matrix[i][j];
                        if (Matrix[i][j] > 0)cout << " ";
                        cout << Matrix[i][j] << " ";
                    }
                    else cout << "    ";
                    break;
                case 'Г':
                case 'г':
                    if (i >= j && i + j >= N - 1)               // условие варианта г)
                    {
                        if (Matrix[i][j] > max)max = Matrix[i][j];
                        if (Matrix[i][j] < min)min = Matrix[i][j];
                        if (Matrix[i][j] > 0)cout << " ";
                        cout << Matrix[i][j] << " ";
                    }
                    else cout << "    ";
                    break;
                case 'Д':
                case 'д':                                       // условие варианта д)
                    if ((i <= j && i + j <= N - 1) || (i >= j && i + j >= N - 1))
                    {
                        if (Matrix[i][j] > max)max = Matrix[i][j];
                        if (Matrix[i][j] < min)min = Matrix[i][j];
                        if (Matrix[i][j] > 0)cout << " ";
                        cout << Matrix[i][j] << " ";
                    }
                    else cout << "    ";
                    break;
                case 'Е':
                case 'е':                                       // условие варианта е)
                    if ((i >= j && i + j <= N - 1) || (i <= j && i + j >= N - 1))
                    {
                        if (Matrix[i][j] > max)max = Matrix[i][j];
                        if (Matrix[i][j] < min)min = Matrix[i][j];
                        if (Matrix[i][j] > 0)cout << " ";
                        cout << Matrix[i][j] << " ";
                    }
                    else cout << "    ";
                    break;
                case 'Ж':
                case 'ж':                                       // условие варианта ж)
                    if (i >= j && i + j <= N - 1)
                    {
                        if (Matrix[i][j] > max)max = Matrix[i][j];
                        if (Matrix[i][j] < min)min = Matrix[i][j];
                        if (Matrix[i][j] > 0)cout << " ";
                        cout << Matrix[i][j] << " ";
                    }
                    else cout << "    ";
                    break;
                case 'З':
                case 'з':                                       // условие варианта з)
                    if (i <= j && i + j >= N - 1)
                    {
                        if (Matrix[i][j] > max)max = Matrix[i][j];
                        if (Matrix[i][j] < min)min = Matrix[i][j];
                        if (Matrix[i][j] > 0)cout << " ";
                        cout << Matrix[i][j] << " ";
                    }
                    else cout << "    ";
                    break;
                case 'И':
                case 'и':                                       // условие варианта и)
                    if (i + j <= N - 1)
                    {
                        if (Matrix[i][j] > max)max = Matrix[i][j];
                        if (Matrix[i][j] < min)min = Matrix[i][j];
                        if (Matrix[i][j] > 0)cout << " ";
                        cout << Matrix[i][j] << " ";
                    }
                    else cout << "    ";
                    break;
                case 'К':
                case 'к':                                       // условие варианта к)
                    if (i + j >= N - 1)
                    {
                        if (Matrix[i][j] > max)max = Matrix[i][j];
                        if (Matrix[i][j] < min)min = Matrix[i][j];
                        if (Matrix[i][j] > 0)cout << " ";
                        cout << Matrix[i][j] << " ";
                    }
                    else cout << "    ";
                    break;
                case '0':
                    cout << "До новых встречь!" << endl;
                    break;
                default:
                    cout << "Неправильно выбран вариант! Проверьте раскладку клавиатуры и попробуйте еще раз!" << endl;
                    dark_side = 'N';                                        // переименовываю чтобы не увязнуть в циклах с выводом выше строки на экран
                    break;                                                  // закрытие switch если у меня 'N' либо '0' (далее еще проверим)
                }
                if (dark_side == '0' || dark_side == 'N')break;             // если у меня 'N' либо '0' выйду из внутреннего цикла
            }
            if (dark_side == '0' || dark_side == 'N')break;                 // если у меня 'N' либо '0' выйду из внешнего цикла
            cout << endl;
        }


        if (dark_side == '0')break;                                         // выход из цикла do_while() (из программы)
        else                                                                // если выбран правильный или неправильный вариант 
            if (dark_side != 'N')                                           // если выбран правильный вариант
            {
                cout << "Максимальный элемент варианта " << dark_side << " равен:  " << max << endl;
                cout << "Минимальный  элемент варианта " << dark_side << " равен: " << min << endl;
                max = -100;                                                 // возвращаем переменные в исходное состояние для повторной работы с матрицей
                min = 100;
            }
        system("pause");
    } while (dark_side != '0');
}