#include <iostream>
using namespace std;

/* Главное научиться попадать в нужный пиксель/место/ячейки/блоки, потом все делается одинакого.

Цикл for очень удобен при работе с табличным выводом на экран, когда мы знаем точное количество строк и столбцов. Построим дом табличным выводом символов. Размер дома
будет N на N кирпичей (квадрат), высота крыши будет тоже N. След, напишем два цикла for, один будет отвечать за крышу, другой за стены. В крыше, помимо черепицы, будут
и пробелы (фон). Основной размер это N, а его определяет ширина дома, относительно которой будем работать со всеми остальными размерами. Индексы нашей таблицы i и j. C
их помощью нужно научиться попадать в нужную ячейку и заполнить ее. А чтобы понимать как это сделать, нам нужно представлять где должен размещаться новый объект относи-
тельно, например, стен или крыши. Сейчас мы только выводим данные в виде таблицы на экран, не сохраняя таблицу в память. Это будет впереди. Кроме ширины дома нам ничего
другого не нужно, далее мы будем отталкиваться от нее в циклах, оперируя счетчиками (индексами i и j). След, переменная будет только одна N (размер поля для рисования).

Как нам начать выводить дом на экран? Что должно появиться раньше, а что позже?
Т.к. у нас код выполняется сверху вниз, первый цикл д/б для крыши. Но начнем мы со стен, а под крышу сделаем лишь заготовку в виде чистого поля с двумя циклами for.
Стены будут с точно такими же циклами, т.к. размер поля такой же как и под крышу.

Чтобы получился красивый дом, его нужно составить из кирпичей. Размер нашей ячейки мы можем создать, в данном случае ширину ячейки. Введем кирпичу 6 символов в ячейку.
Выведя все на экран, мы увидим поле, полностью заполненное кирпичами. А теперь в конкретных местах нарисуем окно, дверь.. Т.о. мы будем заменять новыми объектами неко-
торые кирпичи, точнее вырезать место в кирпичах под нужные объекты. Заполним стены кирпичами. Тут применяется только if else, нужный объект заходит в if, а фон в else.

			Дверь:
Рисуя дверь, мы должны понимать где она должна находиться. Мы оперируем не координатами, а индексами нашей таблицы i и j. Отступим 1 блок от начала для двери. В ширину
будет 2 ячейки, а в высоту есть две возможности:

	1. Статический вариант - жесткое задание ячеек объекта (независимо от изменений размера дома, дверь всегда будет одного размера)
	2. Динамический вариант - чем больше ширина, тем больше дверь (масштабируется вместе с домом)

По ширине дверь сделаем статической. А по высоте, от верха отступим 2 кирпича, а 3-м рядом кирпичей сверху сделаем верхний порог двери, а под ними разместим дверь.
1 столбец будет j==0, второй j==1, ... По счетчику j у нас строгое равенство, т.к. все блоки находятся в одном столбце. А по i сложнее. Eсли мы напишем i==2, то у нас
получится одиночный блок в третьей (сверху) строке.
(!) Если нам нужен всего 1 кирпич, то мы напишем i==2&&j==1. А если нам нужно несколько кирпичей, то нам нужно указать от какого и до какого кирпича. Т.к. у нас у двери
сверху будет отступ, а снизу будет пол до земли, нижнюю границу можно не писать. Достаточно написать i>=3 (0,1,2 отступ для двери). Чтобы было взято НЕСКОЛЬКО БЛОКОВ
нужно НЕРАВЕНСТВО! Если нужен только ОДИН БЛОК - РАВЕНСТВО. Формулировать условие мы можем любым образом. У нас есть размер N - количество кирпичей в ширину и в высоту.
Можно использовать это значение. Но обычно N берется когда мы отталкиваемся от конца (допустим берем 11, делим на 8 и попадаем куда надо и т.д.). Нам же удобнее дверь
строить сверху (0,1,2,[3]). Мы можем двигаться от верхней либо от нижней границы, с левой или с правой границы, от центра можем идти или от любого другого объекта, ко-
торый уже создан. В нашем случае дверь на три блока смещается вниз, поэтому удобнее отступить сверху (от i==0).

	[если разделим на 3, это значит что у нас будет в три раза меньше. Если у нас дом размером 20, станет 6 блоков сверху, а нам нужно всегда 3.
	 Если нам нужен динамеческий объект полностью, ты мы должны отталкиваться от размера или от нуля и фиксировать. И это наш вариант]

i>=3 это значит 0, от которого мы двигаемся +3, а именно от нулевой строчки смещаемся вниз на 3 строки (если мы отнимаем, мы идем вверх, если прибавляем, то идем вниз).
Если напишем, например, i==N-2 это значит на два блока выше конца строки (выше самой нижней строки, от нижней границы навверх). А здесь мы пишем 3, это значит от верх-
ней границы вниз на 3 блока. Когда мы пишем просто цифру это значит мы идем сверху и опускаемся на несколько строк. Тот же принцип и для столбцов, например, j==1, мы
берем от начала с левого края и смещаемся на 1 столбик вправо. Это условие нашей левой стороны двери (i>=3 и j==1).
(!) Если мы решили что каждый блок 6 символов, значит каждый блок 6 символов!
Правая сторона двери будет равна левой. За высоту отвечает счетчик i, значит по i будет такое же условие как и у левой стороны двери. А по j (она находится на столбик
правее) j==2. Снова if else. Т.к. правая сторона двери будет выглядеть иначе, мы не можем их объединить. Т.е. если мы можем несколько блоков нарисовать в разных местах
одинаково, мы можем их объединить. Если не можем, то прийдется писать вручную.

			Верхняя балка:
Нам нужна верхняя балка. Т.к. у нас ширина каждого кирпича 6 символов, мы можем два верхних кирпича объединить в балку. Она горизонтальная, след, счетчик i будет для
них одинаковый (i==2), а по счетчику j балка будет находиться над левой, и над правой половинками дверей, т.е. у нее будет j==1, j==2.

(!) Только не 'И' (&&), а 'ИЛИ' (||). С 'И' будет пересечение блоков (и там, и там одновременно), а у нас они не пересекаются. С 'ИЛИ' мы можем нарисовать там или там.
Счетчик i строго равен 2, а вот по счетчику j у нас 2 условия, и мы должны объединить их в скобки, т.е. у нас должно перемножаться, с помощью логического умножения, ус-
ловие по счетчику i на условие по счетчику j (j==1 ИЛИ j==2). Почему 'ИЛИ'? Раскроем скобочки i==2&&(j==1||j==2):
У нас получатся 2 координаты: 1-я i==2&&j==1 || 2-я i==2&&j==2. У нас получается 'ИЛИ' в этом кирпиче i==2&&j==1, 'ИЛИ' в этом i==2&&j==2 (сразу в двух). Без скобок
j==2 будет непонятно что. А если напишем умножение, то у нас просто перемножится и не получится 2 блока. А нам нужно 2 отдельных блока, где каждый блок это условие по
счетчику i умноженное на условие по счетчику j. В каждом блоке, который мы хотим нарисовать должно быть условие и по счетчику i, и по счетчику j. Иначе не сработает.
Для справки, с 'И' можно сделать так i==2&&j>=1&&j<=2.    (а эта запись i==2&&j==1&&j==2 ничего не даст)

Главное 2 правила:
1. Размер каждого блока одинаковый
2. if else и никак иначе! Соблюдая эти два условия ничто не разъедется

			Дверная ручка:
Чтобы сделать ручку справа, мы должны взять какой-то блок справа и заменить его на уже нарисованный блок с ручкой. Если мы хотим какой-то блок заменить с правой стороны
двери, значит относительно правой стороны двери этот код должен находиться. ЕСЛИ НУЖНО ЗАМЕНИТЬ ОДИН БЛОК ДРУГИМ, ТО ДРУГОЙ БЛОК НУЖНО ПИСАТЬ ВЫШЕ ЗАМЕНЯЕМОГО. У нас
вся стена в кирпичах, и мы их меняем на разные блоки. Если нам нужно чтобы ручка была нарисована поверх правой стороны двери, нам нужно прописать ее выше. Она д/б в if,
а правая сторона должна попасть в else. Как у художника - он сперва нарисует дверь, а потом сверху на ней нарисует ручку на следующий слой сверху. И у нас тоже сверху
описание. Но только у нас наоборот, сперва рисуется ручка, а потом вокруг нее рисуется дверь.

(!) если мы хотим чтобы какой-то объект был на переднем плане ближе к зрителю, то он должен быть выше по коду!
Середина стены это N/2, а нам нужно чуть ниже середины на 1 блок. Высоту определяет i, след, если мы хотим чуть ниже середины двери, двигаясь вниз, мы прибавляем 1 к i.

(!) О скобках при логических операциях: компилятор сначала выполняет деление, потом сложение, сравнение, а только потом.. объединение операций. Главное использовать
скобки там где разные знаки, особенно с И и ИЛИ. Там скобки обязательны! А если у нас много условий, и все операции объединения одинаковые, то скобки можно не ставить.

(!) Чтобы объект был динамическим, нам нужно его привязывать либо к верхнему краю (0), либо к нижнему (N). Т.о. объект будет меняться с изменением высоты (или ширины,
смотря что мы меняем). Ручка будет плавать, но всегда находиться посередине стены с ячейкой ниже.
(!) Если появляются лишние блоки с каких-то краев, значит забыт else. Если линии кривые, то где-то не соблюдается размер символов.

			Порог:
Порог можно сделать где угодно. Но т.к. у нас левая и правая сторона двери не имеют внизу ограничений (i>=3), след, порог у нас д/б описан выше чем наши левая и правая
стороны двери, иначе двери перекроют собой порог. По счетчику i условие будет N-1, т.к. мы начинаем с нуля, а N это общее число. Но порог мы не сможем нарисовать в один
раз, т.к. у него есть и правая, и левая сторона.

			Окно:
Окно можно нарисовать 2-мя способами: с поперечиной или без, и лучше сделать в статическом варианте.
Окно будет состоять из следующих составляющих:
1. Oтдельно две горизонтальные линии. Мы иx нарисуем отдельно. Размер окна: в высоту 5 кирпичей, в ширину 4 кирпича. Чтобы окно постоянно было в центре стены, независи-
мо от размера дома, по высоте будем отталкиваться от середины стены. По ширине отступим от правого края на 1 кирпич. И в итоге мы получим 4 кирпича в ширину и 5 в высо-
ту. Всего 20 кирпичей. Крайние рамы будут разные, а вертикальные центральные будут одинаковые. Т.о. у нас будет 4 условия. Где будем писать окно в коде? Во-первых, окно
должно быть выше кирпичей, а относительно двери непринципиально. Т.к. окно и дверь не пересекаются, можно прописать окно как выше кода двери, так и ниже. Напишем выше.

Как нам найти центр? Центр это N/2, след, по-горизонтали центр будет i==N/2.
1-e, заменим верхние и нижние блоки на линии. Как сформулировать условие чтобы сразу за один присест заменить 8 блоков? Для верхней линии будет условие i==N/2-2. Нижняя
линия будет i==N/2+2. А по j? Последний столбец равен j==N-1, предпоследний j==N-2.., cлед, наша линия от N-5 до N-2 (по j), a по i это две линии N/2-2 и N/2+2.
Тут будет составное условие:
1-я часть это комбинированное условие по i из двух линий (т.к. нам нужно две точные линии, а не диапазон). Возьмем верхнюю и нижнюю горизонталь и напишем равенство i==
и i== .
2-я часть это условие по j. А это диапазон от одного блока до другого. Когда мы говорим про диапазон (несколько блоков, как у нас, целая горизонталь), мы пишем нера-
венство и между условиями ставим объединение И (&&). Cкобки обязательны, т.к. нам нужно общее условие с i перемножить с общим условие по j. В условии c i строгое ра-
венство и операция ИЛИ, т.к. нам нужно в двух местах от ИЛИ (в двух строчках). А в секции с j у нас сравнение (неравенство) и операция И между ними, т.к. нужен диапа-
зон от -5 блока по -2 блок (с j у нас диапазон, а с i лишь две строки). Когда у нас идет диапазон от одной ячейки до другой (j секция) мы пишем неравенство и объедине-
ние И (&&). Когда нам нужно в этой ячейке, а также в той ячейке (только в двух), мы пишел ИЛИ и строгое равенство.
Левые и правые рамы (раз решили сверху писать, так будем сверху и дальше):

			Координаты:
Т.к. у нас это вертикальные линии, то у нас по j будет 1 столбец, а по i аж 3 строчки. След, у нас в i будет диапазон, а в j будет конкретное значение. Левая рама (3
блока): по j будет N-5, а по i от N/2-1 до N/2+1. Читается: i>=N/2-1 &&(и при этом) i<=N/2+1. Еще раз разберем принцип действия:

Между условием по j и по i обязательно (&&) т.к. умножается j на i, а внутри i сценария лог.умножение (&&) ставится т.к. у нас интервал от i>=N/2-1 до i<=N/2+1 т.е. это
интервал от одной строки до другой строки. След, у нас тут будут 3 строки. Когда я писал i==N/2-2 || i==N/2+2, то у меня было 2 строки (только такая и только такая). А
тут у меня уже от этой строки i>=N/2-1 до той строки i<=N/2+1, поэтому между ними и ставится лог.умножение (&&)! Т.е. если нам нужно заполнить все от одного блока до
другого блока, то нужен диапазон и тогда мы пишем объединение И и пишем неравенство. Когда нам нужно в этом блоке или в том блоке (всего в двух), тогда мы их объединяем
через ИЛИ и пишем == (их точные адреса).
(!) если мы хотим чтобы окно всегда было в центре дома, то нужно отталкиваться от центра, от середины по высоте. Напишем j==N/2 и, если надо, со сдвигом в + или в -
(точно также как мы делали по i, привязывая по центру стены в высоту). Если мы хотим чтобы окно всегда было прижато к краю, мы должны отталкиваться от края (N-1) и дви-
гаться. Точка опоры, привязки берется всегда, в любой графике. В статике за опору берут начало координат 0:0, а в динамике нужно браться за ту точку, которая ближе и
логичнее. Но надо быть осторожным т.к. при изменении размера, объект либо будет в той стороне оставаться, к которой мы его привязали, либо будет растягиваться пропорци-
онально размерам нашего дома. Тут уже смотря какое у нас задание.
(!) за верх/низ и за привязку кверху или книзу отвечает счетчик i, а за привязку к той или иной стороне отвечает счетчик j.

			Правая рама:
По i высота будет таже самая, а по j будет N-2 (т.к. должна совпадать с шириной нашего всего окна).
Замену шести центральным блокам можно сделать единажды, т.к. центр сможем сделать одинаковым (центральные вертикальные рамы). По высоте они совпадают с вертикальными
крайними рамами по i, а по ширине, по j эти два набора блоков будут N-3 и N-4, след, по j будет комбинированное условие и строгое равенство, т.к. всего в двух столбцах. */


/* Крыша:
У крыши есть главная диагональ и побочная, соответственно области над главной диагональю (правый верх) и под главной диагональю (левый низ), а также области под побоч-
ной диагональю (правый низ) и над побочной диагональю (левый верх). А нам нужно область "низа песочных часов" выделить, а именно область на пересечении под главной диа-
гональю (i>j) и область под побочной диагональю (i+j>N-1). След, нам нужно эти области объединить (&&). Но формулы со строгими неравенствами (> <) не включают блоки, на-
ходящиеся на самих диагоналях. А чтобы их включить, нужны нестрогие условия (>= <=). Напишем формулу для этой области: i>=j&&i+j>=N-1.
Крышу мы заполним черепицей, а все остальное у нас будет небо.

			Труба:
Сделаем чтобы труба была фиксирована и не съезжала ни при каких размерах. Центр крыши N/2, по j отъедем на 2: j==N/2+2. А по i? Ведь у нас чем выше дом, тем больше бло-
ков в крыше. Если мерить от кирпичной кладки, мы не попадем при увеличенном размере. А сверху отсчитывать тоже неудобно. Что мы тут сделаем? Мы решили, что для красоты
мы возьмем и один блок черепицы заменим. Где находится этот блок относительно всего поля нашей крыши? Он находится на ГД (i==j). j равно N/2+2, след, i тоже равно N/2+2.
Мы получаем уравнение для основания трубы (i==N/2+2)&&(j==N/2+2).
Остальные кирпичи:
Уравнение для основания трубы (i==N/2+2)&&(j==N/2+2). У всех остальных кирпичей по j будут теже самые координаты. Т.к. расположена труба в одном столбце и выше, след,
по i у нас будут след.координаты (наверх это минус, вниз это плюс, вправо это плюс, влево это минус):

	i==N/2+2	&&(j==N/2+2)
	i==N/2+1	&&(j==N/2+2)
	i==N/2		&&(j==N/2+2)
	i==N/2-1	&&(j==N/2+2)	(зная координаты одного кирпича, от него мы уже сдвинулись куда нам нужно)

	Условия для нашей трубы: по счетчику j статичное N/2+2, а по счетчику i от N/2-1 до N/2+2.

Окошечко чердака (выполним перекрестием):
Нужно попасть в середину крыши. Вершина крыши это N/2, а часть ниже - горизонталь окошка 3N/4 (0.75N) - самый центральный блок/перекрестие окна. Создадим окошко для не-
четного числа, добавив вертикальную и горизонтальные рамы (см. код ниже).
При вводе четного числа наше окошко немного сдвинулось. Мы его не будем полностью перерисовывать, а добавим еще одну центральную раму. Сделаем сдвиг горизонтали на 1
блок налево и дорисуем 3 блока в столбце слева.
Можно полностью перерисовать окно. Это будет даже лучше чем прописывать условия, т.к. в коде крыши уже много условий if else. Сделаю так - вырежу весь код крыши, создам
условие if для четной ширины и вставлю туда весь мой код крыши, а в else пропишу нечетную сторону и вставляю туда также весь мой код крыши. Получаю 2 одинаковых блока
кода, но четный код я изменю, словно напишу заново.
Чтобы сдвинуть левую раму влево изменим j == N / 2 + 1 на j == N / 2 - 2.
Добавим перекрестие. Для этого продублирую условие с коррекцией, добавив ||j==N/2-1 (-1 т.к. левее).

(!) если нужно где-то продублировать блок, то добавим и создадим комбинированное условие. Если в соседнем столбце, то добавим по j, а если в соседней строке, то по i.
Ту же логику применим и к вертиральным рамам окошечка, заменив условие j==N/2 условием на составное условие (j == N / 2 || j == N / 2 - 1). */

int main()
{
	cout << "------------------------------------------------------Let's build a house!-----------------------------------------------------------------------" << endl;
	int N = 0;
	cout << "Enter the width of a house: "; cin >> N;

	// Крыша
	for (int i = 0; i < N; i++)																								// цикл по строкам
	{
		for (int j = 0; j < N; j++)																							// цикл по столбцам
		{
			if (N % 2 == 0)																									// если ширина четная
			{
				if ((i == 3 * N / 4 - 1 || i == 3 * N / 4 + 1) && (j == N / 2 || j == N / 2 - 1))cout << "  |   ";			// вертикальная рама окошка
				else
					if (i == 3 * N / 4 && j == N / 2 - 2)cout << " - - -";														// левая центральная рама окошка
					else
						if (i == 3 * N / 4 && j == N / 2 + 1)cout << " - -  ";														// правая центральная рама окошка
						else
							if (i == 3 * N / 4 && (j == N / 2 || j == N / 2 - 1))cout << " -|- -";										// перекрестия окна
							else
								if ((i >= N / 2 - 1 && i <= N / 2 + 2) && (j == N / 2 + 2))cout << "|###| ";								// труба из кирпичей
								else
									if (i >= j && i + j >= N - 1)cout << "|===| ";																// черепица в крыше
									else cout << "      ";																						// небо
			}
			else																											// если ширина нечетная
			{
				if ((i == 3 * N / 4 - 1 || i == 3 * N / 4 + 1) && j == N / 2)cout << "  |   ";								// вертикальная рама окошка
				else
					if (i == 3 * N / 4 && j == N / 2 - 1)cout << " - - -";														// левая центральная рама окошка
					else
						if (i == 3 * N / 4 && j == N / 2 + 1)cout << " - -  ";														// правая центральная рама окошка
						else
							if (i == 3 * N / 4 && j == N / 2)cout << " -|- -";															// перекрестье окна
							else
								if ((i >= N / 2 - 1 && i <= N / 2 + 2) && (j == N / 2 + 2))cout << "|###| ";								// труба из кирпичей
								else
									if (i >= j && i + j >= N - 1)cout << "|===| ";																// черепица в крыше
									else cout << "      ";																						// небо
			}
		}
		cout << endl;
	}

	// Стены
	for (int i = 0; i < N; i++)																								// цикл по строкам
	{
		for (int j = 0; j < N; j++)																							// цикл по столбцам
		{
			if ((i >= N / 2 - 1 && i <= N / 2 + 1) && (j == N - 3 || j == N - 4))cout << "  |   ";							// центральные вертикальные рамы
			else
				if ((i >= N / 2 - 1 && i <= N / 2 + 1) && j == N - 2)cout << "    | ";											// правая вертикальная рама
				else
					if ((i >= N / 2 - 1 && i <= N / 2 + 1) && j == N - 5)cout << "|     ";											// левая вертикальная рама
					else
						if ((i == N / 2 - 2 || i == N / 2 + 2) && (j >= N - 5 && j <= N - 2))cout << "- - - ";							// верхняя и нижняя рамы
						else
							if (i == 2 && (j == 1 || j == 2))cout << "_ _ _ ";																// верх двери
							else
								if (i == N - 1 && j == 1)cout << "|_ _ _";																		// левая половина порога
								else
									if (i == N - 1 && j == 2)cout << " _ _| ";																		// правая половина порога
									else
										if (i >= 3 && j == 1)cout << "|     ";																			// левая сторона двери
										else
											if ((i == N / 2 + 1) && j == 2)cout << "  O | ";																// ручка двери
											else
												if (i >= 3 && j == 2)cout << "    | ";																			// правая сторона двери
												else cout << "|###| ";																							// кирпичи в стене
		}
		cout << endl;
	}
}
/* (!) Для вывода изображения есть такие понятия как буфер экрана и размер окна.
	Буфер экрана - это сколько символов будет выводиться
	Размер окна - это сколько символов будет помещаться */